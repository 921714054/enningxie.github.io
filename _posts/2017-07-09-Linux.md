---
layout: post
title: the Way to Linux
date: 2017-07-09
categories: blog
tags: [Linux]
description: Linux升级之路
---

## 1. 从添加用户开始谈起

Linux中添加一个新的用户，可以使用`adduser`或`useradd`命令。

在Ubuntu中`adduser`是一个脚本，而`useradd`是一个二进制程序，前者对后者进行了封装，更加智能。

但在CentOS中`adduser`和`useradd`完全相同，前者只是一个符号连接。

注意的是，`useradd`在任何Linux发行版都是一样的，所以我们最好牢记它。

添加一个新用户最简单的方法：  
`# useradd enningxie`（注意需要root权限）

上述命令执行后，系统为我们创建了一个新的用户，用户名为“enningxie”。系统在创建过程中帮我们设置好了很多的默认值，包括：创建一个唯一的UID；添加一个与用户名相同的用户组和一个唯一的GID，并将用户设置为该组；在/home目录下创建一个与用户名同名的目录；设置shell为/bin/bash。唯一还没有设置的就是密码了，使用`passwd`命令可以做到这点。

**拓展部分**：

> `usermod`用于修正某些细微的配置参数，比如希望使用一个不同的shell；  
`userdel`用于删除某个用户，`-r`参数选项，把用户的home目录一同删除；  
用户组的管理同用户的管理类似，相似的命令有：`groupadd`、`groupmod`、`groupdel`、`gpasswd`。

## 2. 关于sudo的用法

Linux的用户除了root就是普通用户，而普通用户的权限非常低，就连向系统安装软件的权利都没有。很多时候系统管理员为了能让普通用户具备一点root用户的特权，就可以赋给用户被称为sudo的特权。

给某个用户赋予sudo特权，实际上就是更改/etc/sudoers文件中的内容。在该文件中有一行：  
`root ALL=(ALL) ALL`  
它的含义是说root用户可以使用sudo特权以root权限执行任何命令。

现在，我们想要为一个用户赋予sudo特权，我们可以参照上述写法：  
`enningxie ALL=(ALL) ALL`  

赋予一个用户组的所有用户sudo特权：  
`%groupname ALL=(ALL) ALL`

特殊写法：  
`%groupname ALL=(ALL) NOPASSWD:ALL`  
关键字NOPASSWD，可以使得不需要输入密码即可拥有root权限。这个NOPASSWD并不仅仅作用于用户组，对于我们之前所说的单个用户授权的方法也是有效的。但是这种写法会导致权限过大，（不输密码感觉有点不负责任的样子），所以不建议使用。

`%users ALL=/sbin/mount /mnt/cdrom, /sbin/unmount /mnt/cdrom`  
这一行主要描述了users用户组，可以执行：  
`sudo mount /mnt/cdrom`  
`sudo unmount /mnt/cdrom`  
除了这两条命令之外，其它的都会被Linux系统拒绝。

`%users ALL=(ALL) ALL,!/usr/sbin/adduser,!/usr/sbin/useradd`  
这一行使得users用户组无法使用sudo特权给系统添加新的用户。

新建用户之后，会涉及到用户之间的切换问题；用户间切换使用`su`命令。  
`su`命令就是做临时用户切换的，默认是切换到root用户。`su`在做用户切换的时候也会提示输入密码，但是与`sudo`需要输入自己的密码不同，`su`要求的是输入目标用户密码，退出切换后的用户用`exit`。  
如果不给`su`任何参数，那么它默认切换的是root用户，同时不会更改当前所在的目录。加上`-`参数后，即`su -`，则会改变当前目录到目标用户的home目录。例如：`su enningxie -`，就会立即切换到enningxie用户下，同时当前目录变更为/home/enningxie。  
使用`su`命令，管理员可以任意切换成任何用户，这是给管理员在管理上带来的很大的便利。然而普通用户的隐私，在管理员面前也就完全公开了。  
有意思的是，对于被赋予sudo特权的普通用户来说可以通过执行`sudo su -`跳过root密码，反之用自己的密码进入root用户（tips）。避免这种问题的发生，应该在/etc/sudoers文件中明确禁止`su`被`sudo`特权执行。

## 3. who am i

当用户多了的时候，你又在频繁切换用户，你会想知道最初使用的用户是什么，当前的用户又是什么。专业术语会给出：实际用户（UID）和有效用户（EUID，即Effective UID）。

> 所谓实际用户是指用户登录时所使用的用户，所以在整个登录会话中，实际用户是不会发生变化的；而有效用户则是指当前执行操作的用户，这个是能够利用`su`或`sudo`命令进行任意切换的。一般情况下，实际用户和有效用户是相同的，只有发生用户身份切换的时候才会出现差异。

对于那些经常需要切换用户的系统管理员来说，搞清楚当前使用的是什么身份的用户是一件不太容易的事情，但是对于某些shell脚本，或许需要特别的用户才能执行，那么就需要利用`whoami`（查看有效用户）这个命令来搞清楚执行它的用户是谁；还有一些shell脚本可能不太喜欢被人欺骗，一定要某个特别的用户才能执行，即便是使用`su`切换的都不行，那么需要使用`who am i`（查看实际用户）这个命令来确认。

## 4. 文件和它与权限的关系

**目录与文件**

Linux的文件组织方式是从“/”开始的一颗树，所以“/”也被称为根目录。

在Linux中查看文件和目录的命令是`ls`，它会列出当前目录下的所有目录和文件。

Linux中用颜色来区分目录和文件的，一般的，蓝色代表目录，其它颜色代表文件。

**文件属性和权限**

在Linux系统中，每个文件都会有一个特定的拥有者（一般是创建它的用户）和所属用户组，这是属于它的固有属性。文件可以利用这两个固有属性来规定它的拥有者或者其所属用户组内的用户是否拥有对它的访问权利，即读、写和执行的权利。此外，为了提高适应性，文件还规定了其他不相关人等，也就是第三个固有属性，对它的读、写和执行的权利。这三个固有属性和三个权利合起来，就构成了文件的针对系统中所有用户的访问控制。

`-rwxr-xr-x 1 root root  27776  Apr 17 2012 arch`  
文件属性展示结构，依次分别是：文件类型和权限、连接数、拥有者、所属用户组、文件大小、最后修改日期、文件名。

`-rwxr-xr-x`  
第一个字符用于描述文件类型，可能的取值是：-、d、l、b、c、s和p。“-”代表这是一个普通文件；“d”代表这是一个目录；“l”代表这一个软连接，硬连接；“b”和“c”都代表着设备文件，“b”是块设备，如磁盘等保存大块数据的设备，“c”是字符设备，如鼠标、键盘等需要连续串行读写的设备；“s”代表是套接字（socket）文件；“p”是命名管道文件。  
余下的部分则对应着不同用户群体的读、写和执行权限。

Linux的权限控制很明晰，当某个用户需要访问某个文件时，系统就读取这个文件的属性和权限信息与当前用户的UID和GID进行对比，来确定当前用户是文件的拥有者还是与其所属用户组同组。然后根据这些对比结果和用户所执行的动作来判断是否满足权限要求。这样也就引出了文件权限与命令的一些关系，因为Linux系统中一个文件是否是可执行文件是通过属性来决定的，而不是拓展名。

对于目录，“x”权限可以控制用户是否能够打开它，只有具备“x”权限的用户才能打开这个目录。而如果要想使用`ls`命令来查看这个目录下的文件列表，则必须拥有“r”权限，否则即便能够进入，也无济于事。那么想要在目录中创建文件就需要拥有“w”权限了。

对于其它类型的文件，若想读取则需要“r”权限，若想能够使用编辑器编辑，就必须同时具备“r”和“w”这两个权限。如果一个文件是shell脚本或者其它可执行文件，要能够被执行，应当具备“x”权限。

文件名前面带有“.”的即是隐藏文件，而实际上文件的隐藏属性就是在文件名前添加“.”。

**关于文件连接的问题**

文件连接的问题，也就是上述文件属性中的连接数属性的延伸。要搞清楚这个属性就要搞清楚Linux保存文件的方法。Linux所使用的文件系统是一种基于inode的文件系统。每一个新创建的文件都会被分配一个inode，且每个文件都有一个唯一的inode编号。我们可以将inode简单理解成一个指针，它指向的是文件所在磁盘中的物理位置。系统是通过inode定位每一个文件的，而不是通过文件名。所以通常情况下，为了提高文件系统的执行效率，访问过的文件的inode会被缓存在内存中。那么连接数这个属性其实就是inode的引用计数。为什么要增加这个引用计数呢？原因就在于Linux允许一个文件拥有多个名字。也就是说，文件名只是相当于inode的一次引用。

我们大多数时候所见到的“连接数”都是1，这说明大多数文件都只有一个名字。那么在什么时候文件会有多个名字呢？在使用`ln`命令建立文件连接的时候。`ln`命令可以建立两种文件连接：硬连接和软连接，其中软连接也叫做符号连接。其实软连接不是真正的连接，与Windows中的快捷方式类似，只是一个普通的文件，需要额外增加一个“-s”命令选项来创建。例如：  
`ln -s /bin/bash sh`  
就会创建一个新的软连接sh指向/bin/bash；  
软连接的文件属性和目标文件属性完全不同，按照系统设计，软连接也要占据一个新的inode。也就是说软连接是一个新的文件，不影响inode的引用计数。  
不使用“-s”命令选项创建的就是硬连接。例如：  
`ln /bin/bash bash`  
就会创建一个名为bash的硬连接到/bin/bash。  
硬连接的属性跟目标文件的属性完全相同，因为引用的是相同的inode，仅仅将inode的引用计数进行了+1操作。  
硬连接直接引用了目标文件的inode，它的所有属性也都引用进来了。

> 输入删除文件连接的目标文件，则软连接（快捷方式）会失效，而硬连接则仅是“连接数”-1。  
软连接可以创建在任何位置，包括网络，而硬连接则不行，目标文件与连接文件必须在同一个磁盘分区内。  
软硬连接在使用的时候区别不大，都相当于是一个文件具有不同的路径和文件名。

**修改文件的属性和权限**

首先说明，要想操纵文件的属性和权限，你必须具备对文件的写权利，或者是root。

修改文件所属用户组使用的命令是`chgrp`，但是这个命令不是很常用。因为另外一个命令`chown`也能够完成跟它一样的活。`chown`是更改文件的拥有者，命令格式为：  
`chown [-R] username filename`  
或者  
`chown [-R] username:group filename`  
当使用第二种格式的时候，会连同文件所属用户组一同修改，其中"-R"参数是可选的，且仅在修改目录的时候有用，意思是递归性修改，也就是将目录下的所有文件包括子目录在内全都更改成指定的拥有者。

改变文件的权限需要使用的命令为`chmod`，一般有两种方法：数字法和文字法；

所谓数字法就是使用数字来代替r，w，x，r等同于4，w等同于2，x等同于1。权限组合就用这些数字的和来表示。比如r-x权限就是5，rw-权限就是6，而rwx权限就是7。范例：  
`chmod 700 .bashrc`  

文字法首先引入了四个字母u、g、o、a，分别代表拥有者、所属组、其他和全部。接着引入了三个操作符+、-、=，分别代表增加、减去和设定。  
如果要给拥有者增加w权限，可以使用u+w代表。举个例子，去掉.bashrc文件的执行权限，可以这样操作：  
`chmod a-x .bashrc`  
或 `chmod ugo-x .bashrc`  
或 `chmod -x .bashrc`

小知识点：  
> Linux中有几个特别的目录名，分别是："."/".."/"-"/"~"。  
其中在任何目录下都能被看到的是"."和".."，分别代表的是当前目录和上一级目录。  
在根目录"/"下"."和".."是完全相同的，都代表根目录"/"。  
由于"."目录的存在，使得每一个目录的连接数属性为2；由于".."的存在，目录中每增加一个子目录，其连接数属性+1；所以"."和".."就是实际的文件硬连接的例子。  
目录"-"和"~"从来没有出现在磁盘中，他们实际上只是cd命令的一个特殊参数。"-"代表上一个工作目录，而"~"代表当前用户的home目录。由于它们的特殊性，所以不建议将真实的目录命名为"-"或"~"。  

**搜索文件**

Linux系统一共提供了5个搜索文件的命令。

其中搜索文件最简单快速的方法是使用`whereis`命令，例如：`whereis ls`，就可以搜索到ls命令以及它的联机帮助文档所在的位置。

虽然`whereis`命令既简单又高效，但功能却很有限。它只能用于搜索可执行文件、联机帮助文件和源代码文件。如果要获得更全面的搜索结果，可以使用`locate`命令。

其实在Linux中更为常见的搜索命令是`which`。这个命令比上述所有的命令都要简单，它只是在$PATH环境变量（用于保存可执行文件的默认搜索路径）中指定的路径来搜索可执行文件的所在位置。它一般用来确认系统中是否安装了指定的软件。比如要确认是否安装了gcc，可以使用命令：`which gcc`来确认。

`type`命令比较特别，实际上`type`命令是用来判断一个命令是否属于shell内置的。如果是非那种的shell命令，并且使用了`type`的"-p"选项，该命令就相当于是`which`命令了。

最后一个搜索命令是`find`命令，`find`命令十分强大，关于`find`命令的具体用法求助man。

**对文件打包压缩**

Linux中对文件的打包和压缩都是同一个命令`tar`。

在使用Linux过程中，你会发现这样的一些文件：\*.tar.gz、\*.tar.bz2、\*.tar.xz。这些文件统称为“tar”包，其不同的结尾，表明所使用的压缩算法不同。压缩比从低到高的排序是gz<bz2<xz，而压缩速度正好相反。

解压缩tar包非常简单：`tar -vxf filename`。

创建tar包可能有点麻烦，但是也只是比解压的时候多了一个命令选项，而这个多出来的命令选项就是所采用的压缩算法。z代表gz，j代表bz2，J代表xz。所以创建一个tar包，可以使用这样的命令：  
`tar -zcvf filename.tar.gz FILES`  
`tar -jcvf filename.tar.bz2 FILES`  
`tar -Jcvf filename.tar.xz FILES`  
其中FILES代表要被打包和压缩的文件或这目录的名称。

除了tar这个打包压缩工具之外，Linux下还有dump和restore这一对备份还原工具能够提供对文件进行打包和解包工作。此外，还有一个比较重要的工具cpio，它主要是用来备份任何东西的，也能够实现对文件的打包。

## 5. 程序的执行问题

所谓前台任务就是当前与我们交互的程序，而后台任务就是虽然执行着但是不与我们交互的程序。与图形界面不同，在命令行下，前台任务是我们唯一可见的任务。后台任务要想成为前台任务，必须先将当前的前台任务切换成后台任务。要把当前任务切换成后台任务需要使用快捷键Ctrl+Z。

而我们想直接创建一个后台任务，也可以直接在命令末尾添加“&”符号来完成。例如：`tail -f /etc/profile &`。

命令`jobs`用于查看这些任务。

`bg`查看后台任务。

`fg 1`切换相应的任务。

`kill -9 %2`其中"-9"是一个信号，这个信号会强制干掉一个不正常的任务或进程。最后的2代表的是要被kill掉的进程id。

**全面了解程序信息**

`ps`命令主要是查看程序的静态信息，即将某个时间的程序运行情况截取下来。  
比较常用的方法有：  
> `ps aux`：查看系统中所有程序的数据；  
`ps ux`：查看当前用户所有程序的数据；  
`ps -l`：查看与当前终端关联的程序数据。

如果期望动态监测系统中程序的运行状态，可以使用`top`命令。

`top`命令输出非常丰富，而且每隔5秒就会刷新一次。

`ps`和`top`命令可以很方便地获取单个进程的信息。如果要查看进程的父子祖先关系，虽然`ps`命令能够满足，但是最方便的应该是`pstree`了。

## 6. 软件的安装方式

**从源码安装软件**

从源码安装离不开安装“三部曲”。在此之前，因为不确定源码中是否包含上次编译过的目标文件（\*.o），我们最好用`make clean`或`make distclean`去除目标文件，以保证新编译出来的可执行文件是在自己机器上编译完成的。

第一步：configure  
它被用来检查待安装源码的Linux系统的相关软件属性，创建Makefile文件。这一很关键，随后需要的安装信息都是从这一步中获取的。建议实现阅读下源码安装包目录下的README或INSTALL相关的文件，这样有助于我们正确设置参数。

第二步：make  
make根据Makefile的指示开展编译工作，利用gcc将原始码编译成为目标文件，这些目标文件通过函数库连接产生一个完整的可执行文件。此时这个可运行文件还没有被安装到预定安装的目录，仍然在当前编译目录下。

第三步：make install  
make根据Makefile这个文件里面关于install的项目，将上一步所编译完成的文件安装到预定的目录中。一般有etc、lib、bin、和man等目录分别代表配置文件、函数库、执行文件、线上说明文件。

这种方式安装的软件因为没有做软件相关性检查会导致它依赖的其他软件不存在或者版本不正确，从而有可能无法正常运行。

**利用软件管理工具rpm和dpkg**

利用源码安装存在上述依赖问题，Linux中引入了软件管理机制进行软件包的安装、更新和卸载。

Linux系统上最通用的两个软件管理工具rpm和dpkg。

||RPM|DPKG|
|:---:|:---:|:--:|
|全称|Red Hat Packge Manager(Red Hat包管理器)|Debian Package(Debian软件包管理器)|
|文件名|RPM软件包的命名遵循名称-版本-修正版-类型这种格式。例如Magiclinux-3.0.2-1.i386.rpm|DEB软件包的命名遵循名称-版本-修正版-类型这种格式。例如Magiclinux-3.0.2-1.i386.deb|
|安装|rpm -ivh <rpm软件包名>，如：`rpm -ivh Mysoftware-1.2-1.i386.rpm`|dpkg -i <deb软件包名>|
|查询|当你只知道软件名称，在卸载前需要确定这个软件的完整名称时，你可以使用`rpm -qa xxx*`查找RPM包软件。xxx指软件名称开头的几个字母。查找此软件向系统里写入的文件列表，使用`rpm -ql <rpm包名>`|通配符模式进行模糊查询`dpkg -l xxx*`。查询系统中属于xxx软件的文件：`dpkg --listfiles xxx`|
|卸载|rpm -e <rpm软件包名>，如`rpm -e Mysoftware`（注意此处是软件名而不是软件包名）|`dpkg -e <deb软件名>`|

RPM更多地被企业所应用。需要说明的是RPM在被安装之前，为了避免文件被错误安装会先检查系统的硬盘容量、操作系统版本等，所以RPM文件必须要在相同的Linux环境下才能安装。

为了接触上述限制很多软件制作者还提供了***.src.rpm这种格式来命名的SRPM软件包。SRPM提供了配置档，即configure与makefile。这样虽然SRPM内容是源码，但仍含有所需要的相关性软件说明、以及所有RPM文件所提供的数据。在安装该软件以RPM管理的方式编译RPM文件，然后将编译完成的RPM文件安装到Linux系统当中。

**更酷的线上升级**

上述dpkg/rpm这些机制并没有完全解决软件属性相依的问题。为了解决依赖问题，Linux给出了线上升级的策略。这种策略的实施过程是系统先制作这些相依属性的软件列表，在安装某个软件包的时候，先到这个软件列表去找，同时与系统内已安装的软件比较。这样没安装的相依软件就能一次性全部安装起来。

不同Linux开发商采用的工具不同，dpkg管理机制出现了APT线上升级机制，而RPM根据开发商的不同采用的工具也不一样，其中RedHat系统的yum，SUSE系统的Yast Online Update(YOU)，Mandriva的urpm软件等。

介绍Linux系统上最流行的两个线上升级工具：apt和yum。

||yum|apt-get|
|:---:|:---:|:---:|
|简介|yum是yellowdog updater modified的缩写。yellowdog是一个Linux的distribution，Red Hat将这种升级技术利用到自己的distribution形成了现在的yum|APT是Advance Packaging Tool的缩写。它包含以“apt-”开头的多个工具：apt-get、apt-cache和apt-cdrom等|
|安装|`yum install <package_name>`|`apt-get install <package_name>`|
|升级|`yum update <package_name>`|刷新软件源，建立更新软件包列表：`apt-get update`；将系统中的所有软件包一次性升级到最新版本：`apt-get upgrade`|
|卸载|`yum remove <package_name>`|`apt-get remove <package_name>`；清除软件包的同时清除配置：`apt-get purge remove <package_name>`|
|查询|查找软件包：`yum search <keyword>`；列出所有已经安装的软件包：`yum list installed`；获取软件包信息：`yum info <package_name>`；列出软件包提供哪些文件：`yum provides <package_name>`|查找软件包：`apt-cache search <keyword> or <regular expression>`；获取指定软件包的详细信息：`apt-cache show <package_name>`；获取软件包版本和软件包的依赖关系：`apt-cache showpkg <package_name>`|
|清除缓存|下载的软件包和header存储在cache中不会自动删除。使用`yum clean`完成清除磁盘空间的工作；清除header：`yum clean headers`；清除下载的rpm包：`yum clean packages`；清除缓存的软件包以及旧的headers：`yum clean all`|清除整个软件包缓冲区：`apt-get clean`；按照依赖关系清理缓冲区中多余的软件包：`apt-get autoclean`|

yum和apt的原理类似，apt的执行效率高于使用Python写成的yum。既然yum是利用Python脚本语言实现的，所以在Python升级问题上要慎重，否则会导致yum工作不正常，系统无法实现线上升级了。

## 7. 磁盘的管理方式

**文件系统**

FAT32是在Windows95时代开始采用的文件系统，到现在都有人在用（U盘），可以说是伴随着我们成长的文件系统。FAT是File Allocation Table的缩写，从字面意义上就能看出这是一个类似表格一样的文件系统。由于其用于描述文件大小的属性是一个32位的值，导致其能够支持的单个文件最大不能超过4G。

NTFS是微软专门为NT系统设计的，单个文件最大可以达到2T。现在最为常用的Windows XP和Windows 7都支持NTFS。

由于Linux文件系统（ExtN 索引式文件系统）的特性，基本上不需要进行磁盘碎片整理。但其实一个使用很久的Linux系统也会因为磁盘碎片问题而变慢，这也是事实。

**磁盘的基本操作**

常用的文件操作命令：`ls`/`cd`/`cp`/`rm`/`mv`。虽然它们也都是作用在磁盘上，但是它们面向的对象更为高级一些，属于文件范畴。而我们现在要介绍的是稍微低级一点，面对的是文件的载体——磁盘的一些基本操作。最常用的是：`df`/`du`/`dd`/`fsck`/`mount`。

`df`命令用于查看系统中所有磁盘的整体用量。

具体指派哪个分区与哪个目录对应，就由`mount`命令来指定。这个目录被称为“挂载点”。

在Linux系统中，/dev目录下的所有文件都与一个具体的设备有关，有物理的，也有虚拟的。而sda1就是一个物理的设备，它对应系统第一块串口硬盘的第一个分区。第二个分区以此类推sda2，而对应整块硬盘则是sda。第二块串口硬盘应该是sdb。

`df`命令是用来观察总体磁盘使用量的，要观察局部使用量，需要使用`du`命令。`df`命令可以通过读取磁盘的superblock来实现，而`du`命令则不同，它要搜索所有的inode来计算局部数据，所以`du`命令的执行效率，经常要比`df`差很多。

`fsck`命令用于对文件系统的损坏进行修复。

Linux下，只需要特意创建一个目录即可，如果需要单独的磁盘分区来存储它，使用`mount`命令指定给它就好了。一般用法：  
`mount [-t 文件系统] 设备名称 挂载点`  
比如我们要将系统中第二块串口硬盘的第一个分区挂载到/data目录下，可以这样使用：  
`mount /dev/sdb1 /data`或`mount -t vfat /dev/sdb1 /data`  
很多时候“-t”参数是多余的。第二种用法多数用于挂载Windows分区时使用。

与`mount`命令相反的操作就是卸载了，使用`umount`命令。它的操作更加简单，给定挂接点目录或具体设备就行了。如：`umount /data`或`umount /dev/sdb1`

用于磁盘分区的命令是`fdisk`，比`fdisk`更好用的一些分区工具是`cfdisk`。
